[
  {
    "objectID": "posts/week1_reflections.html",
    "href": "posts/week1_reflections.html",
    "title": "Week 1 Reflections",
    "section": "",
    "text": "I soldered surface mount and through hole components on the MicroPs development board. To test the board, I flashed simple programs on the FPGA and MCU to establish viewable communication between the two."
  },
  {
    "objectID": "posts/week1_reflections.html#summary",
    "href": "posts/week1_reflections.html#summary",
    "title": "Week 1 Reflections",
    "section": "",
    "text": "I soldered surface mount and through hole components on the MicroPs development board. To test the board, I flashed simple programs on the FPGA and MCU to establish viewable communication between the two."
  },
  {
    "objectID": "posts/week1_reflections.html#reflections",
    "href": "posts/week1_reflections.html#reflections",
    "title": "Week 1 Reflections",
    "section": "Reflections",
    "text": "Reflections\nSoldering surface mounted parts provided me with a new challenge that was quite exciting and frustrating simultaneously. I enjoyed Radiant’s intuitive FPGA design flow process compared to other IDE synthesizers like Xilinx Vivado."
  },
  {
    "objectID": "posts/lab2.html",
    "href": "posts/lab2.html",
    "title": "Lab 2",
    "section": "",
    "text": "Hello all! I just finished my second lab in microPs and I’m overly satisfied that it’s completed. There was a period of time where I didn’t think I was going to be able to meet all requirements due to a frustrating bug that was introducing floating values to my design. In the end, the bug was addressed and put to rest.\nThe most exciting part about the project was figuring out how to properly multiplex the display. It took some time to wrap my head around the idea of time multiplexing. After figuring out how to do it, the next hardest step was learning how a PNP transistor worked. I’ve never had experience with BJTs before. I preferred the method of researching the component then using trial and error to find the perfect fit for my design.\nAs mentioned before, I encountered a very frustrating bug. Whenever a user applied a specific sequence of inputs, all voltages in every component became floating values on the development board and breadboard. Even ground was off! After many hours of trying to track down the bug, I noticed that the issue was due to the internal pull-up resistors in the FPGA development board. The default 100k ohms was too large along with the next lowest resistor value of 10k. I had to set the pull-up resistors to the minimum value that the tool allowed me to set the resistors to: 3.3k ohms. This worked wonders on my problem! As one can imagine after experiencing a frustrating bug like this, I was hyped up and jumping around with my hands in the air when the bug was fixed! Note that I did attempt to put smaller pull-up resistors on a breadboard while avoiding using the internal resistors, however, this brought floating values along with it."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Hello Quarto",
    "section": "",
    "text": "Hi everyone! My name is Troy!"
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2",
    "section": "",
    "text": "Lab2 Setup\n\n\n\nSummary\nThis lab introduced students to a method of reusing valuable resources - multiplexing. In this case, students were required to time multiplex a dual 7-segment display along with illustrating the sum between two hexadecimal numbers shown on the display. SystemVerilog modules were created to build a multiplexing FSM, 7-segment decoder, and adder respectively. This lab took a total of 15 hours to complete. Nine of these hours were focused on debugging a floating value problem in the mechanical design which will be mentioned in the design section. Overall, all requirements were met.\n\n\nDesign\nA top module instantiated a Lattice Radiant clock, multiplexing FSM, 7-segment decoder, and adder. The main part of this design revolved around an FSM turning on one side of a dual 7-segment display at a time while sending the appropriate hexadecimal data to the segment decoder for the number to be displayed. This FSM included 3 states: S0 (reset), S1 (1st hex number), S2 (2nd hex number). Once the active low reset button was driven, the FSM would alternate from S1 to S2 at a fast enough pace for a human not to notice flickering but slow enough to avoid bleeding the numbers together on the display. The A and Abar signals on the state transistion diagram arcs represent counter inputs to the FSM. Only when the counter has reached a specific value is when the A arc is followed. Otherwise, the Abar arc is followed.\n\n\n\nState Transistion Diagram\n\n\nAs mentioned before, there are four submodules in the overall design. Below is the system block diagram. The hex_num_controller module contains the FSM. It will receive a clock and active low reset input. It will output two transistor signals to drive the display and one encoded signal, display_num, to the segment_decoder module. This encoded signal will tell the segment_decoder module which hexadecimal input to illustrate on the display. All the while this happens, an adder in led_sum will sum the two inputs and show the result on five LEDs.\n\n\n\nBlock Diagram\n\n\nTo properly multiplex the dual 7-segment display, two PNP transistors controlled their own common anode pins on the display. One would supply a flow of current to a number’s segments while the other transistor would limit the current, thus, turning one number on and the other one off. To protect the FPGA from current damage coming from the emitter, a 330 ohm resistor was put in series with the base. This limited the FPGA to output a current of 7.8 mA, below the soft 8 mA recommended maximum output current listed in the FPGA data sheet on Table 4.13 on pg 34.\nThe PNP 2N3906 transistor current gain for this particular instance can be found on pg 6 in Figure 13.\nThe following calculation and explanation shows why a 330 ohm resistor was used in the design. \nThe current limiting resistors for the cathode inputs into the display and LED sum calculation is as follows:\n\n\n\nCurrent Limiting Resistor Calculation\n\n\nThe electrical schematic shown below displays all the electrical components needed to complete the requirements including the dual 7-segment display, DIP switches, and current limiting resistors. Note that the DIP switches are using internal pull-up resistors as noted in the development board’s schematic\n\n\n\nElectrical Schematic\n\n\nAs previously mentioned, I did encounter a frustrating issue with floating values in my design. Initial debug attempts were focused at resoldering, using new switch inputs, using new ribbon cable, etc. Eventually, the problem was tracked down to the internal pull-up resistors. Their default values on the Lattice Radiant tool is 100k ohms. I found that using 3.3K ohms was perfect to prevent the floating value problem.\n\n\nVerification\nTestbenches were used to verify my design in simulation. The design worked in all testbench assessments.\nThe unit 7-segment decoder testbench was used to check if all segments in a hexadecimal number would be driven properly. Stimulants in the testbench tested all 16 numbers. All of them were correct. \nThe following testbench checked if the internal encoded display_num signal would be properly set/reset after a given number of clock cycles. The blue signal shows the encoded signal. The purple and orange signals show the current inputs to the transistors for driving the hex number display. We wanted to see the that the FSM behavior would show the encoded signal being driven whilst the hex2_num signal was reset to low and vice versa with the hex1_signal. A high enconded signal with a low hex2_num signal prompts the system to display the second number. A low encoded signal with a low hex1_num prompts the system to display the first number.\n\n\n\nFSM Hexadecimal Display Controller Waveform\n\n\nThis testbench tests if the adder works correctly. This is a simple combinational testbench that works fine. \nThis system testbench tests the entire design’s effectiveness to a variety of switch inputs. Overall, this testbench design is very similar to the FSM testbench except for the fact that the high speeded oscillator clock is instantiated in this one. \nOverall, my design worked as planned and successfuly implemented the requirements in lab 2. This lab took me a total of 15 hours. The source code for the lab can be found here."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Troy Kaufman is a junior general engineering major at Harvey Mudd College. He has a deep interest in digital design with hopes of entering the computer architecture field. As an intern with The Aerospace Corporation this past summer, he worked on facilitating communication between an FPGA and SPI NOR flash memory. Troy also created an FPGA subsystem that monitored and replied to a proprietary satellite interface. His hobbies include playing disc golf, scripted wrestling, and building weird devices with friends."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Lab 3\n\n\n\n\n\nKeypad Scanning\n\n\n\n\n\nSep 19, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\n\n\n\n\n\n\nLab 2\n\n\n\n\n\nTime Multiplexing a Dual 7-Segment Display\n\n\n\n\n\nSep 13, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\n\n\n\n\n\n\nLab 1\n\n\n\n\n\nConfiguring a 7-segment display and LEDs\n\n\n\n\n\nSep 2, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\n\n\n\n\n\n\nWeek 1 Reflections\n\n\n\n\n\nBuilt my development board and began to program in SystemVerilog\n\n\n\n\n\nAug 30, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\n\n\n\n\n\n\nHello Quarto\n\n\n\n\n\nWeek 1 Update\n\n\n\n\n\nAug 27, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1",
    "section": "",
    "text": "Image of Lab 1 Setup\n\n\n\nSummary\nLab 1 introduced students to the digital design world by giving them experience with FPGA design flow from creating block diagrams to synthesizing hardware on an FPGA. The main goals of this lab were to produce a 2.4 Hz blinking LED along with driving other LEDs based on XOR and AND logic. Additionally, a seven segment display would illustrate the current hexadecimal number input from the DIP switches located on the development board.\nSeveral SystemVerilog modules produced the necessary logic to perform the requirements, and circuit analysis was used to calculate component values to drive the seven segment display according to the Specs sheet.\nOverall, this lab took 9 hours to finish which included soldering the development board together and fixing ST-link/J-link issues along with the hardware design and debugging.\n\n\nDesign\nThe first aspect to consider in the project was separating the design approaches for the two main goals: blinking an LED and driving a seven segment display. A top module would instantiate these two designs named led_controller and seg_decoder along with providing a high speed oscillator (48 MHz) developed by Lattice Radiant as seen in the BLOCK DIAGRAM BELOW.\n\n\n\nSystem Block Diagram\n\n\nThe seven segment display source code (seg_decoder) could be handled by strictly utilizing combinational logic via a case statement. The seven segment display was cathode driven, so, +3V3 supplied voltage to the common anode while the seven bit signals were attatched to the display via current limiting resistors. The calculation for the resistor values is as follows:\n\n\n\nCurrent Limiting Resistor Calculations\n\n\nWhere Vcc is the voltage source, Vd is the voltage drop across the LED, I is the desired current, and Rn is the resistor value. Solving for Rn gave a resistance value of 60 ohms for the current limiting resistors. These components contributed to the overall schematic as seen below:\n\n\n\nSystem Schematic\n\n\nThe DIP switches, reset button, and LEDs with current limiting resistors are shown in Prof. Brake’s schematic for the development board linked here.\nAs for the blinking LED (led_controller), a counter was used to delay setting the LED. The calculation is the following:\n\n\n\nCounter Limit Calculations\n\n\nThe counter limit value determines the blinking frequency with the associated clock. A reset signal initializes the counter and LED state to both 0. Until the counter reaches the desired limit, the counter increments by 1 and the LED retains its value on each clock cycle. Once the limit is achieved, the counter is reset and the LED’s value is negated thus turning the LED on/off at the desired freqeuncy.\nThe additional goals included driving XOR and AND logic on LEDs which were produced by assign statements housed inside the LED controller source code.\n\n\nVerification\nTo verify the design, an oscilloscope was used to measure the blinking LED’s freqeuncy while testbenches stimulated the source code.\nThe oscilloscope image below shows that the LED was blinking at 2.404 Hz - well within the vicinity to be considered acceptable.\n\n\n\nOscilloscope trace of a 2.4 Hz signal\n\n\nThe seg_decoder module was tested by inputting all possible switch combinations (2^4). The designer would have to manually verify that the module worked as intended by checking if each hexadecimal output was correct for each successive input.\n\n\n\nseg_decoder Waveform\n\n\nFurthermore, a testbench was created for the led_controller which now included a custom ~48MHz clock to run the sequential logic. The Lattice HSOSC library couldn’t be accessed, so a makeshift one was created. Once again, all switch combinations were supplied to the module so that the designer could analyze the XOR and AND logic. If one wished to observe the 2.4 Hz behavior for the third LED, they could do so if they had all day to wait.\n\n\n\nled_controller Waveform\n\n\nFinally, a system testbench was made to test the two submodules together. This testbench contained the same stimulus package as the led_controller testbench had.\n\n\n\nTop Module Waveform\n\n\nThe verification for all submodules and top module were successful including the oscilloscope test mentioned above. All requirements were satisfied."
  },
  {
    "objectID": "labs.html",
    "href": "labs.html",
    "title": "E155 Labs",
    "section": "",
    "text": "Lab 2\n\n\n\n\n\nTime Multiplexing a Dual 7-Segment Display\n\n\n\n\n\nSep 13, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\n\n\n\n\n\n\nLab 1\n\n\n\n\n\nSeven Segement Display and LED logic\n\n\n\n\n\nSep 3, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/lab1.html",
    "href": "posts/lab1.html",
    "title": "Lab 1",
    "section": "",
    "text": "Hi all! I recently finsihed the first lab in MicroPs, and it was overwhelmingly satisfying to see my hardwork pour into a successful project. Despite the premise being to turn on LEDs in various fashions, the lab was gruelling in some aspects. This lab was a neat introduction to the digital design world.\nThe most exciting part about the lab was designing the counter needed to blink an LED at 2.4 Hz. There is a handful of ways to perform this operation, and I did end up trying some of them out to see which method would produce the closest blinking freqeuncy. It was fun trying this out. However, this ended up being one of the most frustrating parts of the lab as well. I incorrectly gave my counter 22 bits when in reality it needed 25 bits to operate. This oversight caused hours of pain and eventual embarassment aft the bug was caught.\nOverall, this was an entertaining lab that showed me the FPGA design flow in Lattice Radiant. It took sometime getting used to the new tool, howeever, I don’t doubt that with some practice I can maneuver around with no difficulty."
  },
  {
    "objectID": "posts/lab3.html",
    "href": "posts/lab3.html",
    "title": "Lab 3",
    "section": "",
    "text": "First off, this was a time consuming and gruelling lab. I spent over 40 hours on the lab, and I still haven’t finished it. However, it’s been a wonderful learning experience filled with “Ah-Ha” and “Oh-No” moments. This lab built off the two previous ones where counters were used in multiple places and the time multiplexing scheme was used to display the pressed keys.\nDesigning, implementing, and debugging this system was an entirely different beast. Clock domain crossing was considered, debouncing logic was needed, many submodules communicated with each other, and a complex FSM was built to scan the keypad in such a way to account for all possible human inputs and tomfoolery when it came to pressing keys on the keypad. Despite not having finished it like most others, I am proud of the work I’ve done so far, and I’m determined to finish the lab in the next couple days.\nThe digital design aspect of this course has been a great introduction to digital electronics. I’m looking forward to the next FPGA based lab in about a month or so when we create AES on an FPGA and MCU."
  }
]