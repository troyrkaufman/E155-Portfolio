[
  {
    "objectID": "posts/week1_reflections.html",
    "href": "posts/week1_reflections.html",
    "title": "Week 1 Reflections",
    "section": "",
    "text": "I soldered surface mount and through hole components on the MicroPs development board. To test the board, I flashed simple programs on the FPGA and MCU to establish viewable communication between the two."
  },
  {
    "objectID": "posts/week1_reflections.html#summary",
    "href": "posts/week1_reflections.html#summary",
    "title": "Week 1 Reflections",
    "section": "",
    "text": "I soldered surface mount and through hole components on the MicroPs development board. To test the board, I flashed simple programs on the FPGA and MCU to establish viewable communication between the two."
  },
  {
    "objectID": "posts/week1_reflections.html#reflections",
    "href": "posts/week1_reflections.html#reflections",
    "title": "Week 1 Reflections",
    "section": "Reflections",
    "text": "Reflections\nSoldering surface mounted parts provided me with a new challenge that was quite exciting and frustrating simultaneously. I enjoyed Radiant’s intuitive FPGA design flow process compared to other IDE synthesizers like Xilinx Vivado."
  },
  {
    "objectID": "posts/lab4.html",
    "href": "posts/lab4.html",
    "title": "Lab 4",
    "section": "",
    "text": "Lab 4 was concerned with exposing students to bare metal programming on an MCU to produce the song, Fur Elise. This lab took a lot of patience because there were many configuration registers that needed to be accounted for withing the 1600 page document. After hours of reading through documentation, it was immensely satifying to see my design output a square wave on the oscilloscope and even more so when the song played in its entirety from the speaker.\nBesides the fact that it was very easy to leave out an important register in the code, my most frustrating bug came with my delay function. It was frustrating because my pwm function was working just fine - which is a more complex version of the delay function! I was making two major mistakes: wrong oscilloscope interpretations and missed configuring two parts of a timer register. The fatal flaw that held me back for hours was the wrong oscillscope interpretation. In my mind I though that the delay was being produced correctly because the next note in the song would be played after some time…when I pressed the next step button in the debugger. Essentially, I wasn’t checking my delay function at all on the oscilloscope - yikes.\nOverall, this was a fun lab to complete with some minor hiccups here and there. The main lesson I learned from this was to take notes on all the important registers that MIGHT need to be configured in my design to build a record. Doing this could have saved me a handful of hours of rereading documentation."
  },
  {
    "objectID": "posts/lab2.html",
    "href": "posts/lab2.html",
    "title": "Lab 2",
    "section": "",
    "text": "Hello all! I just finished my second lab in microPs and I’m overly satisfied that it’s completed. There was a period of time where I didn’t think I was going to be able to meet all requirements due to a frustrating bug that was introducing floating values to my design. In the end, the bug was addressed and put to rest.\nThe most exciting part about the project was figuring out how to properly multiplex the display. It took some time to wrap my head around the idea of time multiplexing. After figuring out how to do it, the next hardest step was learning how a PNP transistor worked. I’ve never had experience with BJTs before. I preferred the method of researching the component then using trial and error to find the perfect fit for my design.\nAs mentioned before, I encountered a very frustrating bug. Whenever a user applied a specific sequence of inputs, all voltages in every component became floating values on the development board and breadboard. Even ground was off! After many hours of trying to track down the bug, I noticed that the issue was due to the internal pull-up resistors in the FPGA development board. The default 100k ohms was too large along with the next lowest resistor value of 10k. I had to set the pull-up resistors to the minimum value that the tool allowed me to set the resistors to: 3.3k ohms. This worked wonders on my problem! As one can imagine after experiencing a frustrating bug like this, I was hyped up and jumping around with my hands in the air when the bug was fixed! Note that I did attempt to put smaller pull-up resistors on a breadboard while avoiding using the internal resistors, however, this brought floating values along with it."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Hello Quarto",
    "section": "",
    "text": "Hi everyone! My name is Troy!"
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab 4",
    "section": "",
    "text": "Summary\nStudents needed to bare metal program their MCUs to play Fur Elise on an 8-ohm speaker. The purpose of this lab was to get students familiar with navigating a large datasheet for relevant information pertaining to the project at hand as well as interact with an MCU on a very low level. The lab intoduced timers which are specialized counters with extreme accuracy. Students needed to configure timers to produce the requested frequency and delay to properly produce the song. Device drivers were made from scratch too.\n\n\nDesign\nPrior to this lab, I was familiar with configuring GPIO and RCC registers, however, I needed to understand how timers worked. Before I began designing anything, I researched the various timers available on the MCU. I chose timers 15 and 16 because they had output pads and contained the PWM function unlike other available timers. The harware components this lab were relatively simple to setup:\n\n\n\nDesign’s Electrical Schematic\n\n\nI focused on how to produce a PWM signal first. The reference manual for this particular STM32xxx on page 906 ambiguously stated how to configure a timer for a PWM operation. I made note of these important signals and bit flipping. I traveled to the timer 16’s memory mapped section. Within my TIMER device driver, I created two functions whose purpose were to initialize the PWM configuration for timer 16 once and to update several configuration registers upon every clock cycle respectively. The most notable registers were the prescalar (PSC) and auto-reload (ARR) registers.\nThe PSC acted as a clock divider to either improve or decrease resolution according to the designer’s request. In this project I needed my freqeuncies to be within 1% of the requested freqeuncies. So I put my input clock to the counter to be 10 KHz wheras the input clock to the timer was 1 MHz. The relatively low 10 KHz clock speed provided good resolution. I calculated the PSC divisor value by using the following equation:\n\n\n\nPrescalar Divisor Equation\n\n\nThe next important configuration register to consider was the ARR. This register held the value that the counter would increment towards to in order to produce the requested freqeuncy. I recognized the following relationship between the value housed in ARR and the input frequency where CK_CNT represents the 10 KHz counter input and CK_PSC is the 1 MHz signal.\n\n\n\nARR PWM Calculation\n\n\nMy design choices for the counter clock forces my minimum and maximum frequency calculations to be the following:\nCalculation for minimum frequency supported: This is calculated by first considering the the counter’s input clock frequency (10 KHz) and bit width of the counter (16 bits as discussed in the manual on page 887). By assuming that the counter will reach 65536 ticks, we can find the value for when the MCU will output its lowest freqeuncy:\n\n\n\nMinimum Freqeuncy Supported\n\n\nCalculation for maximum freqeuncy supported: This is calculated very similarly to the minimum frequency calculation. However, the amount of times the counter has clicked will no longer be the counter’s maximum value but rather its minimum value - 1:\n\n\n\nMaximum Frequency Supported\n\n\nNow we will cover how I implemented a delay function for a given duration. It is a similar process to how I implemented the PWM mode for timer 16. I used timer 15, and put the timer in its upcounting mode to strictly increment. Most of the same registers used for implementing the PWM signal were used for the delay function with an exception for a handful that were used for comparison registers. I created initialization and update functions for the delay where the former would only ever update those registers once while the update function would consistently refresh the values in several registers. The major difference between the PWM and delay functions was that there was a while loop with the delay update function checking for when a flag would be set when the duration limit had been satisfied. At that point, the while loop would end and the flag would be reset for the next delay then the next line would run.\nThe PSC calculation for the delay register is the same as the one in the PWM register.\nThe ARR calculation is different because we are no longer receiving an input frequency but rather a duration. To build this equation, I had to consider how fast the tick in the counter would increment in upcounting mode (page 893 in the reference manual). With a 10 KHz input counter clock, the counter would tick every 100 us. So, the duration was multiplied by 10 to get the the duration in terms of ms. Then a value of one was subtracted from this to get the following ARR equation:\n\n\n\nARR Delay Calculation\n\n\nMy design choices for the counter clock forced my minimum and maximum duration calculations to be the following:\nCalculation for minimum duration supported: This is the reciprocal of the input counter clock, 10 KHz.\n\n\n\nMinimum Duration Calculation\n\n\nCalculation for maximum duration supported: The maximum duration is calculated by dividing the maximum number of ticks in the 16 bit counter by the input clock frequency entering the counter:\n\n\n\nMaximum Duration Calculation\n\n\n\n\nVerification\nThe design works perfectly. The only quirk about it is that it takes about 4 seconds for the system to start performing the song after the program starts. I spent about 15 hours on this lab.\nThis is a video of my design playing Fur Elise with volume manipulation from a potentiometer. \nThis is a video that displays my Happy Birthday song. \nBelow are calculations that show the individual pitches are accurate to within 1% of the requested freqeuncy. The measured values seen in the images are captured from an oscilloscope.\n \nThis was a very fun lab, and I can’t wait to play more songs!"
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2",
    "section": "",
    "text": "Lab2 Setup\n\n\n\nSummary\nThis lab introduced students to a method of reusing valuable resources - multiplexing. In this case, students were required to time multiplex a dual 7-segment display along with illustrating the sum between two hexadecimal numbers shown on the display. SystemVerilog modules were created to build a multiplexing FSM, 7-segment decoder, and adder respectively. This lab took a total of 15 hours to complete. Nine of these hours were focused on debugging a floating value problem in the mechanical design which will be mentioned in the design section. Overall, all requirements were met.\n\n\nDesign\nA top module instantiated a Lattice Radiant clock, multiplexing FSM, 7-segment decoder, and adder. The main part of this design revolved around an FSM turning on one side of a dual 7-segment display at a time while sending the appropriate hexadecimal data to the segment decoder for the number to be displayed. This FSM included 3 states: S0 (reset), S1 (1st hex number), S2 (2nd hex number). Once the active low reset button was driven, the FSM would alternate from S1 to S2 at a fast enough pace for a human not to notice flickering but slow enough to avoid bleeding the numbers together on the display. The A and Abar signals on the state transistion diagram arcs represent counter inputs to the FSM. Only when the counter has reached a specific value is when the A arc is followed. Otherwise, the Abar arc is followed.\n\n\n\nState Transistion Diagram\n\n\nAs mentioned before, there are four submodules in the overall design. Below is the system block diagram. The hex_num_controller module contains the FSM. It will receive a clock and active low reset input. It will output two transistor signals to drive the display and one encoded signal, display_num, to the segment_decoder module. This encoded signal will tell the segment_decoder module which hexadecimal input to illustrate on the display. All the while this happens, an adder in led_sum will sum the two inputs and show the result on five LEDs.\n\n\n\nBlock Diagram\n\n\nTo properly multiplex the dual 7-segment display, two PNP transistors controlled their own common anode pins on the display. One would supply a flow of current to a number’s segments while the other transistor would limit the current, thus, turning one number on and the other one off. To protect the FPGA from current damage coming from the emitter, a 330 ohm resistor was put in series with the base. This limited the FPGA to output a current of 7.8 mA, below the soft 8 mA recommended maximum output current listed in the FPGA data sheet on Table 4.13 on pg 34.\nThe PNP 2N3906 transistor current gain for this particular instance can be found on pg 6 in Figure 13.\nThe following calculation and explanation shows why a 330 ohm resistor was used in the design. \nThe current limiting resistors for the cathode inputs into the display and LED sum calculation is as follows:\n\n\n\nCurrent Limiting Resistor Calculation\n\n\nThe electrical schematic shown below displays all the electrical components needed to complete the requirements including the dual 7-segment display, DIP switches, and current limiting resistors. Note that the DIP switches are using internal pull-up resistors as noted in the development board’s schematic\n\n\n\nElectrical Schematic\n\n\nAs previously mentioned, I did encounter a frustrating issue with floating values in my design. Initial debug attempts were focused at resoldering, using new switch inputs, using new ribbon cable, etc. Eventually, the problem was tracked down to the internal pull-up resistors. Their default values on the Lattice Radiant tool is 100k ohms. I found that using 3.3K ohms was perfect to prevent the floating value problem.\n\n\nVerification\nTestbenches were used to verify my design in simulation. The design worked in all testbench assessments.\nThe unit 7-segment decoder testbench was used to check if all segments in a hexadecimal number would be driven properly. Stimulants in the testbench tested all 16 numbers. All of them were correct. \nThe following testbench checked if the internal encoded display_num signal would be properly set/reset after a given number of clock cycles. The blue signal shows the encoded signal. The purple and orange signals show the current inputs to the transistors for driving the hex number display. We wanted to see the that the FSM behavior would show the encoded signal being driven whilst the hex2_num signal was reset to low and vice versa with the hex1_signal. A high enconded signal with a low hex2_num signal prompts the system to display the second number. A low encoded signal with a low hex1_num prompts the system to display the first number.\n\n\n\nFSM Hexadecimal Display Controller Waveform\n\n\nThis testbench tests if the adder works correctly. This is a simple combinational testbench that works fine. \nThis system testbench tests the entire design’s effectiveness to a variety of switch inputs. Overall, this testbench design is very similar to the FSM testbench except for the fact that the high speeded oscillator clock is instantiated in this one. \nOverall, my design worked as planned and successfuly implemented the requirements in lab 2. This lab took me a total of 15 hours. The source code for the lab can be found here."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Troy Kaufman is a junior general engineering major at Harvey Mudd College. He has a deep interest in digital design with hopes of entering the computer architecture field. As an intern with The Aerospace Corporation this past summer, he worked on facilitating communication between an FPGA and SPI NOR flash memory. Troy also created an FPGA subsystem that monitored and replied to a proprietary satellite interface. His hobbies include playing disc golf, scripted wrestling, and building weird devices with friends."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Reflection 5\n\n\n\n\n\nPCB design and Lab 5\n\n\n\n\n\nOct 8, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\n\n\n\n\n\n\nLab 4\n\n\n\n\n\nMusic Playing MCU Bare Metal\n\n\n\n\n\nOct 3, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\n\n\n\n\n\n\nLab 3\n\n\n\n\n\nKeypad Scanning\n\n\n\n\n\nSep 19, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\n\n\n\n\n\n\nLab 2\n\n\n\n\n\nTime Multiplexing a Dual 7-Segment Display\n\n\n\n\n\nSep 13, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\n\n\n\n\n\n\nLab 1\n\n\n\n\n\nConfiguring a 7-segment display and LEDs\n\n\n\n\n\nSep 2, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\n\n\n\n\n\n\nWeek 1 Reflections\n\n\n\n\n\nBuilt my development board and began to program in SystemVerilog\n\n\n\n\n\nAug 30, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\n\n\n\n\n\n\nHello Quarto\n\n\n\n\n\nWeek 1 Update\n\n\n\n\n\nAug 27, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1",
    "section": "",
    "text": "Image of Lab 1 Setup\n\n\n\nSummary\nLab 1 introduced students to the digital design world by giving them experience with FPGA design flow from creating block diagrams to synthesizing hardware on an FPGA. The main goals of this lab were to produce a 2.4 Hz blinking LED along with driving other LEDs based on XOR and AND logic. Additionally, a seven segment display would illustrate the current hexadecimal number input from the DIP switches located on the development board.\nSeveral SystemVerilog modules produced the necessary logic to perform the requirements, and circuit analysis was used to calculate component values to drive the seven segment display according to the Specs sheet.\nOverall, this lab took 9 hours to finish which included soldering the development board together and fixing ST-link/J-link issues along with the hardware design and debugging.\n\n\nDesign\nThe first aspect to consider in the project was separating the design approaches for the two main goals: blinking an LED and driving a seven segment display. A top module would instantiate these two designs named led_controller and seg_decoder along with providing a high speed oscillator (48 MHz) developed by Lattice Radiant as seen in the BLOCK DIAGRAM BELOW.\n\n\n\nSystem Block Diagram\n\n\nThe seven segment display source code (seg_decoder) could be handled by strictly utilizing combinational logic via a case statement. The seven segment display was cathode driven, so, +3V3 supplied voltage to the common anode while the seven bit signals were attatched to the display via current limiting resistors. The calculation for the resistor values is as follows:\n\n\n\nCurrent Limiting Resistor Calculations\n\n\nWhere Vcc is the voltage source, Vd is the voltage drop across the LED, I is the desired current, and Rn is the resistor value. Solving for Rn gave a resistance value of 60 ohms for the current limiting resistors. These components contributed to the overall schematic as seen below:\n\n\n\nSystem Schematic\n\n\nThe DIP switches, reset button, and LEDs with current limiting resistors are shown in Prof. Brake’s schematic for the development board linked here.\nAs for the blinking LED (led_controller), a counter was used to delay setting the LED. The calculation is the following:\n\n\n\nCounter Limit Calculations\n\n\nThe counter limit value determines the blinking frequency with the associated clock. A reset signal initializes the counter and LED state to both 0. Until the counter reaches the desired limit, the counter increments by 1 and the LED retains its value on each clock cycle. Once the limit is achieved, the counter is reset and the LED’s value is negated thus turning the LED on/off at the desired freqeuncy.\nThe additional goals included driving XOR and AND logic on LEDs which were produced by assign statements housed inside the LED controller source code.\n\n\nVerification\nTo verify the design, an oscilloscope was used to measure the blinking LED’s freqeuncy while testbenches stimulated the source code.\nThe oscilloscope image below shows that the LED was blinking at 2.404 Hz - well within the vicinity to be considered acceptable.\n\n\n\nOscilloscope trace of a 2.4 Hz signal\n\n\nThe seg_decoder module was tested by inputting all possible switch combinations (2^4). The designer would have to manually verify that the module worked as intended by checking if each hexadecimal output was correct for each successive input.\n\n\n\nseg_decoder Waveform\n\n\nFurthermore, a testbench was created for the led_controller which now included a custom ~48MHz clock to run the sequential logic. The Lattice HSOSC library couldn’t be accessed, so a makeshift one was created. Once again, all switch combinations were supplied to the module so that the designer could analyze the XOR and AND logic. If one wished to observe the 2.4 Hz behavior for the third LED, they could do so if they had all day to wait.\n\n\n\nled_controller Waveform\n\n\nFinally, a system testbench was made to test the two submodules together. This testbench contained the same stimulus package as the led_controller testbench had.\n\n\n\nTop Module Waveform\n\n\nThe verification for all submodules and top module were successful including the oscilloscope test mentioned above. All requirements were satisfied."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3",
    "section": "",
    "text": "Lab 3 Setup\n\n\n\nSummary\nThe third digital design installation in microPs involved scanning a keypad and presenting the most recently pressed key on the right side of a dual 7-segment display with the number on the left displaying the previous key pressed. The purpose for this lab was to expose students to a complex digital system with many seqeuntial and combinational elements. Additionally, the lab forced students to use oscilloscopes to fix the many timing problems that they would encounter during the debugging phase. To complete this lab, I created a design that would scan through the keypad’s columns allowing the rows to input voltages to the FPGA to be properly detected and decoded. Although this sounds simple, it was not.\n\n\nDesign\nEssentially, the scanner FSM will detect a key press and send output signals to the keypad’s columns and to the keypad decoder to preserve the current key press. While the key is still pressed, a keypad decoder decodes the key that was pushed. To verify the key push, a debouncer FSM debounces the row input signal to avoid double counting due to the switch bouncing phenomena. After the key pushed is verified to be an actual key push, the previous number gets the current number and the current number pressed is updated to the key that was pushed. These two two numbers are then sent to the time multiplexing system that displays the current number pressed on the right of the display and the previous number on the left. The block diagram for this is shown below.\n\n\n\nSystem Block Diagram\n\n\nI created this design by first deciding that my keypad would be oriented in a pull-up resistor fashion where the row inputs would be pulled to Vcc at all times until an event occurs. I then created the scanner FSM that would rotate a LOW voltage on one column at a time while the rest were driven HIGH. Thus if a key was pressed, the current column that was set LOW would send this LOW voltage across the SPDT switch that was pushed down enabling a LOW voltage to be read on that associated row. This grounding effect overpowers the weak internal pull-up resistor on the rows allowing a valid logic level voltage to be read. The electrical schematic for the system is shown below.\n\n\n\nElectrical Schematic\n\n\nIt is important to mention that the scanner FSM toggles the LOW and HIGH column voltage. When a key is pressed, all columns are driven LOW to avoid potential contention scenarios. On the otherhand when no key push is detected, all columns are toggled HIGH except for one to scan the keypad. In addition to this, the FSM sends an encoded column signal to a combinational keypad decoder module to properly decode the key press. Below is the state transition diagram for the scanner FSM.\n\n\n\nScanner FSM STD\n\n\nThis encoded column signal is bit swizzled along with the row input to check for specifc combination cases for keys. If a condition is verified, the key pushed is assigned the proper number along with a flag signal, row_bit, that is sent to the debouncer. If a key is pressed and held down, the key flag is still driven HIGH to keep the keypad from bumping the current number to the previous number.\nThe debouncer FSM takes in the row input signal that was pressed down on. This module recieves the key flag and steps into the first state to begin the counting phase. When enough clock cycles have passed, an enable signal is driven HIGH and sent to the next module that updates the current number and previous number. To prevent accidental double counting, the pulsed enable signal is driven HIGH for only one clock cycle. The state transition diagram for this FSM can be seen below along with a signal diagram.\n\n\n\nDebouncer FSM STD\n\n\nThe design updates the current and previous number through simple sequential logic. Before the current number is updated to the key pushed, the previous number gets the current number. This situation is only every carried out when the pulsed enable signal is HIGH.\nFinally, the updated current number and previous number is sent to the time multiplexing system built from lab 2. The numbers are shown on the 7-segment display on their respective sides. These numbers are illuminated every 60 clock cycles where they alternate on every set of 60 meaning that while one side is displayed, the other is turned off. This is due to the nature of the time multiplexing system where only one 7-segment decoder is used.\nAlthough syncrhonizers have not been implemented yet, they will be put in shortly in the coming week to further mitigate metastability in the system.\nOverall, the design meets the proficiency requirements. In the coming week, I will update the system to meet the excellence requirement. A shocking ~50 hours were spent on this lab. The first half of this involved not realizing that my original pull-down design for the keypad did not meet the logic level requirements for the FPGA. LOW signals would be interpreted as LOW signals, however, HIGH signals would never make it past the VIL logic level of 0.8 volts. This permanently froze the system at “00” on the display making it quite a difficult and frustrating problem to debug because the simulations showed that there should be number changes. My next short coming that led to the ridiculous amount of hours spent on the lab was confusing the active LOW logic with active HIGH at times. This led to me outputting incorrect values to the keypad’s columns creating once again a frozen system on the display. Hours of probing eventually made me realize my mistake. The last major bug that contributed to the ~50 hour effort was the keypad bumping scenario mentioned near the beginning of the design section. When a key was pressed and if the user pressed another key in a different row and in any of the columns then released the most recent key pushed, the previous number would updated to the current number. The problem here was that the key flag was being reset to zero when a key release was detected thus resetting the debouncer counter. As a result, unwanted pulsed enable signals were updating the current and previous numbers to the key that was still pressed. Putting a conditional statement within the default of a case statement fixed this issue.\n\n\nVerification\nTo verify my design, I created testbenches and manually checked the waveforms for correctness.\nThe scanner FSM received clock, reset, and row input signals. Based off of the current column signal output to the keypad, the FSM will either continue to scan or enter the pressed/released states. \nThe keypad decoder module receives the following 4 bit signals: column signal ouput to the keypad, an encoded column signal to be decoded, and a row signal. If one of the eight combinations are reached, the keypad decoder will update the key pushed value and send a row bit output as a HIGH logic value. If a combination goes to the default case, a conditional statement is reached and will check the column signals outputted to the keypad. If the logic sees that a key is still being pressed, the row bit signal will continue to be asserted HIGH and LOW otherwise. \nThe debouncer FSM recieves a clock, reset, and row bit input. When the system detects a HIGH value for the row bit, a counter starts. If the counter reaches the desired threshold, the pulse enabled signal will be driven HIGH for one clock cyle and LOW otherwise. If the row bit continues to be HIGH after this, the counter will not start back up and a LOW output will be driven through the pulse enabled wire. \nThe slide state module receives a clock, reset, pulsed enabled input, and the 4 bit key pushed signals. On the rising edge of the clock, a conditional statement check if the pulsed enabled input is set HIGH. If so, the previous number will be updated to the current number. Then, the current number will get the key pushed value.\n\nThis is the system simulation. In yellow is the current state for the scanner FSM. In purple is the key that was pushed. In cyan are the current number and previous number values. My design works for all inputs into the system. All requirements were met for proficiency."
  },
  {
    "objectID": "labs.html",
    "href": "labs.html",
    "title": "E155 Labs",
    "section": "",
    "text": "Lab 4\n\n\n\n\n\nBare Metal Programming on an MCU to Produce Music\n\n\n\n\n\nOct 3, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\n\n\n\n\n\n\nLab 3\n\n\n\n\n\nScanning and Debouncing a Keypad\n\n\n\n\n\nSep 19, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\n\n\n\n\n\n\nLab 2\n\n\n\n\n\nTime Multiplexing a Dual 7-Segment Display\n\n\n\n\n\nSep 13, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\n\n\n\n\n\n\nLab 1\n\n\n\n\n\nSeven Segement Display and LED logic\n\n\n\n\n\nSep 3, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/lab1.html",
    "href": "posts/lab1.html",
    "title": "Lab 1",
    "section": "",
    "text": "Hi all! I recently finsihed the first lab in MicroPs, and it was overwhelmingly satisfying to see my hardwork pour into a successful project. Despite the premise being to turn on LEDs in various fashions, the lab was gruelling in some aspects. This lab was a neat introduction to the digital design world.\nThe most exciting part about the lab was designing the counter needed to blink an LED at 2.4 Hz. There is a handful of ways to perform this operation, and I did end up trying some of them out to see which method would produce the closest blinking freqeuncy. It was fun trying this out. However, this ended up being one of the most frustrating parts of the lab as well. I incorrectly gave my counter 22 bits when in reality it needed 25 bits to operate. This oversight caused hours of pain and eventual embarassment aft the bug was caught.\nOverall, this was an entertaining lab that showed me the FPGA design flow in Lattice Radiant. It took sometime getting used to the new tool, howeever, I don’t doubt that with some practice I can maneuver around with no difficulty."
  },
  {
    "objectID": "posts/lab3.html",
    "href": "posts/lab3.html",
    "title": "Lab 3",
    "section": "",
    "text": "First off, this was a time consuming and gruelling lab. I spent over 40 hours on the lab, and I still haven’t finished it. However, it’s been a wonderful learning experience filled with “Ah-Ha” and “Oh-No” moments. This lab built off the two previous ones where counters were used in multiple places and the time multiplexing scheme was used to display the pressed keys. Designing, implementing, and debugging this system was an entirely different beast. Clock domain crossing was considered, debouncing logic was needed, many submodules communicated with each other, and a complex FSM was built to scan the keypad in such a way to account for all possible human inputs and tomfoolery when it came to pressing keys on the keypad. Despite not having finished it like most others, I am proud of the work I’ve done so far, and I’m determined to finish the lab in the next couple days. The digital design aspect of this course has been a great introduction to digital electronics. I’m looking forward to the next FPGA based lab in about a month or so when we create AES on an FPGA and MCU."
  },
  {
    "objectID": "posts/reflection5.html",
    "href": "posts/reflection5.html",
    "title": "Reflection 5",
    "section": "",
    "text": "PCB design was fun.\nLab 5 was initially difficult to wrap my head around.\nVector Tables for interrupts.\nEmbedded systems are fun\nI now know that there is a STM tool that is used in industry that contains many well defined functions."
  }
]