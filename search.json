[
  {
    "objectID": "posts/week1_reflections.html",
    "href": "posts/week1_reflections.html",
    "title": "Week 1 Reflections",
    "section": "",
    "text": "I soldered surface mount and through hole components on the MicroPs development board. To test the board, I flashed simple programs on the FPGA and MCU to establish viewable communication between the two."
  },
  {
    "objectID": "posts/week1_reflections.html#summary",
    "href": "posts/week1_reflections.html#summary",
    "title": "Week 1 Reflections",
    "section": "",
    "text": "I soldered surface mount and through hole components on the MicroPs development board. To test the board, I flashed simple programs on the FPGA and MCU to establish viewable communication between the two."
  },
  {
    "objectID": "posts/week1_reflections.html#reflections",
    "href": "posts/week1_reflections.html#reflections",
    "title": "Week 1 Reflections",
    "section": "Reflections",
    "text": "Reflections\nSoldering surface mounted parts provided me with a new challenge that was quite exciting and frustrating simultaneously. I enjoyed Radiant’s intuitive FPGA design flow process compared to other IDE synthesizers like Xilinx Vivado."
  },
  {
    "objectID": "posts/reflection8.html",
    "href": "posts/reflection8.html",
    "title": "Reflection 8",
    "section": "",
    "text": "The SPI temperature lab has wrapped up nicely after a simple hardware bug was fixed. This was a satisfying lab with a good introduction to using a logic analyzer. I’ve used Vivado’s internal logic analyzer in the past, and it was an absolute pain to use. I thought that using a hardware LA might be better and thankfully I was right!!! I’ll definitely be using logic analyzers more in the future because of their flexibilty.\nAs I begin to work on the last lab, I’m looking toward to the project and how my time will be spent on it. I have spent around 140 hours in the past two months working on the various labs. I have contributed a great deal of my time towards this class, and I don’t regret it. However, I need to manage my time better with this class. I’ve been thinking of a plan to bring this to fruition: draw out plans early in the morning every other day then implement the idea for up to three hours later in the day.\nI know that my project requires me to do a lot of work, but I think scheduling designated times for working on the project will be beneificial for my mindset and other aspects of my life. I can’t wait to start ont he project!!!"
  },
  {
    "objectID": "posts/reflection6.html",
    "href": "posts/reflection6.html",
    "title": "Reflection 6",
    "section": "",
    "text": "It’s been a stressful week due to midterms, however, fall break is finally upon us. I was able to get my interrupt lab checked off for proficiency, but my timer lab did not pass. This was due to my scaled down clock input to the timer being too small which forced my auto-reload register counter to become a small and sometimes odd value. This small and off value caused inconsistencies in the delay and note frequenices. Simply decreasing the prescalar value fixed everything.\nI’m currently attempting the lab 5 excellence mark and it has been a familiar story to completing labs 2 and 3. Two hours into debugging, I finally noticed that my HIGH logic level inputs to the MCU were set in the forbidden zone. This was weird because my logic level inputs were fine when I had a rising edge interrupt system. Eventually, I got everything to work and I will be getting excellence on labs 4 and 5.\nMore recently, I have been planning out my final project - image edge detection. A camera would take an image and send it to the MCU where the DMA would transfer the data in a double buffer system to an SRAM. While one buffer was receiving data and waiting for an interrupt to trigger upon the buffer being filled, the other buffer would send its data to the core to be processed into a grayscale format. Another DMA channel would store this in SRAM until the FPGA would trigger a hardware interrupt event. When this would happen, the second channel would send its data over SPI to the FPGA to finally have the edge detection filter applied to the image.\nBoth the FPGA and MCU contain a limited amount of resources so it was essential to choose what image processing steps would take place and where it would happen to conserve precious resources like adders, multipliers, and embedded RAM.\nThis is going to be a really fun project!"
  },
  {
    "objectID": "posts/lab4.html",
    "href": "posts/lab4.html",
    "title": "Reflection 4",
    "section": "",
    "text": "Lab 4 was concerned with exposing students to bare metal programming on an MCU to produce the song, Fur Elise. This lab took a lot of patience because there were many configuration registers that needed to be accounted for withing the 1600 page document. After hours of reading through documentation, it was immensely satifying to see my design output a square wave on the oscilloscope and even more so when the song played in its entirety from the speaker.\nBesides the fact that it was very easy to leave out an important register in the code, my most frustrating bug came with my delay function. It was frustrating because my pwm function was working just fine - which is a more complex version of the delay function! I was making two major mistakes: wrong oscilloscope interpretations and missed configuring two parts of a timer register. The fatal flaw that held me back for hours was the wrong oscillscope interpretation. In my mind I though that the delay was being produced correctly because the next note in the song would be played after some time…when I pressed the next step button in the debugger. Essentially, I wasn’t checking my delay function at all on the oscilloscope - yikes.\nOverall, this was a fun lab to complete with some minor hiccups here and there. The main lesson I learned from this was to take notes on all the important registers that MIGHT need to be configured in my design to build a record. Doing this could have saved me a handful of hours of rereading documentation."
  },
  {
    "objectID": "posts/lab2.html",
    "href": "posts/lab2.html",
    "title": "Reflection 2",
    "section": "",
    "text": "Hello all! I just finished my second lab in microPs and I’m overly satisfied that it’s completed. There was a period of time where I didn’t think I was going to be able to meet all requirements due to a frustrating bug that was introducing floating values to my design. In the end, the bug was addressed and put to rest.\nThe most exciting part about the project was figuring out how to properly multiplex the display. It took some time to wrap my head around the idea of time multiplexing. After figuring out how to do it, the next hardest step was learning how a PNP transistor worked. I’ve never had experience with BJTs before. I preferred the method of researching the component then using trial and error to find the perfect fit for my design.\nAs mentioned before, I encountered a very frustrating bug. Whenever a user applied a specific sequence of inputs, all voltages in every component became floating values on the development board and breadboard. Even ground was off! After many hours of trying to track down the bug, I noticed that the issue was due to the internal pull-up resistors in the FPGA development board. The default 100k ohms was too large along with the next lowest resistor value of 10k. I had to set the pull-up resistors to the minimum value that the tool allowed me to set the resistors to: 3.3k ohms. This worked wonders on my problem! As one can imagine after experiencing a frustrating bug like this, I was hyped up and jumping around with my hands in the air when the bug was fixed! Note that I did attempt to put smaller pull-up resistors on a breadboard while avoiding using the internal resistors, however, this brought floating values along with it."
  },
  {
    "objectID": "posts/first-post.html",
    "href": "posts/first-post.html",
    "title": "Hello Quarto",
    "section": "",
    "text": "Hi everyone! My name is Troy!"
  },
  {
    "objectID": "labs/lab7/lab7.html",
    "href": "labs/lab7/lab7.html",
    "title": "Lab 7",
    "section": "",
    "text": "The Advanced Encryption Standard (AES) is a FIPS-approved cryptographic algorithm that can be used to protect electronic data. The systematic block encrypts data in this design while a testbench compares the ciphertext output to the 128-bit value. The algorithm manipulates plaintext inputs by a combination of adding, substituting, multiplying, and shifting rows/columns many times over to make the data unintelligble to outsiders. My design adheres to the 128-bit AES spec, and passes both the algorithm and SPI testbenches. This link displays a great visual representation of the algorithim. The lab took me around 20 hours to get it working in simulation."
  },
  {
    "objectID": "labs/lab7/lab7.html#addroundkey",
    "href": "labs/lab7/lab7.html#addroundkey",
    "title": "Lab 7",
    "section": "AddRoundKey",
    "text": "AddRoundKey\nThe add_round_key module adds the input state to the current round key coming from key_expansion via an XOR operation. The only exception to this is in the beginning of the algorithm where the input state, plaintext, is added to an unmodified key."
  },
  {
    "objectID": "labs/lab7/lab7.html#subbytes",
    "href": "labs/lab7/lab7.html#subbytes",
    "title": "Lab 7",
    "section": "SubBytes",
    "text": "SubBytes\nThe sub_byte module substitutes a predefined value for a specific input according to the NSA’s documentation. Each byte possibilty has a unique substitution value."
  },
  {
    "objectID": "labs/lab7/lab7.html#shiftrows",
    "href": "labs/lab7/lab7.html#shiftrows",
    "title": "Lab 7",
    "section": "ShiftRows",
    "text": "ShiftRows\nThe shift_rows module shifts each row a different amount of times for an entire state. The first row is not shifted. The second row is one byte over while the third row is shifted by two bytes. Finally, the third row is shifted over by three bytes. The output is now different from the word input. The design’s output is now different from the input"
  },
  {
    "objectID": "labs/lab7/lab7.html#mixcolumns",
    "href": "labs/lab7/lab7.html#mixcolumns",
    "title": "Lab 7",
    "section": "MixColumns",
    "text": "MixColumns\nThe mixcolumns module makes use of Galois field operations on bytes in a column. A strange sequence of multiplication and XOR operations take place according to the 128-bit standards."
  },
  {
    "objectID": "labs/lab7/lab7.html#keyexpansion",
    "href": "labs/lab7/lab7.html#keyexpansion",
    "title": "Lab 7",
    "section": "KeyExpansion",
    "text": "KeyExpansion\nThe key_expansion module creates a new round key for every round in the algorithm. According to the AES standards, the previous key is taken as the input where its rows are shifted to the left by one byte thanks to rot_word. Then sub_byte is performed on the key. Further XOR operations and parsing are performed on the new round key."
  },
  {
    "objectID": "labs/lab7/lab7.html#debugging",
    "href": "labs/lab7/lab7.html#debugging",
    "title": "Lab 7",
    "section": "Debugging",
    "text": "Debugging\nI had two interesting bugs in this design that both involved counters. 1. Keeping track of the current round 2. Not driving the done bit for long enough\nI was using the current round count one clock cycle later than I intended. This proved disasterous because my key_expansion module depended on correctly tracking round to calculate the next round_key. This design used recursion to update the key which forced all of my outputs to be in contention since my expected round count was 1 increment behind the actual value.\nThe second bug was quite interesting because it was found in the AES_spi top module whereas the design worked fine in the AES_core module. The problem here was that the done bit was not being driven HIGH long enough to allow the entire cyphertext to be clocked and received by the other device. Simply fixing the bit range for done from 6 bits to 9 bits made the design work.\nThis lab took me around 20 hours to complete and it meets the proficiency standard."
  },
  {
    "objectID": "labs/lab5/lab5.html",
    "href": "labs/lab5/lab5.html",
    "title": "Lab 5",
    "section": "",
    "text": "Quadrature Encoder"
  },
  {
    "objectID": "labs/lab5/lab5.html#motors-direction",
    "href": "labs/lab5/lab5.html#motors-direction",
    "title": "Lab 5",
    "section": "Motor’s Direction",
    "text": "Motor’s Direction\nI calculated direction by using this “leading” and “lagging” behavior. I placed an interrupt on signal A’s output. When the interrupt triggered, the program would look at the current B signal output. If B was LOW, then the motor’s direction was CCW and CW if B was HIGH.\nInitializing the interrupt took a number of steps:\n\nEnabling SYSCFG in RCC to set up the clock domain\nConfiguring the EXTICR register to make input encoder signals A and B hold contain interrupts\nEnabling interrupts globally\nMasks bits corresponding to the MCU pins used\nEnable rising edge interrupt trigger in RTSR corresponding to the MCU pin used\nDisabling the falling edge interrutp trigger in FTSr corresponing to the MCU pin used\nTurn on the EXTI interrupt found in NVIC_ISER (Position Table corresponds to bit manipulated)\nCreating the IRQHandler corresponding to the EXTI interrupt used in the NVIC_ISER"
  },
  {
    "objectID": "labs/lab5/lab5.html#interrupt-flowchart",
    "href": "labs/lab5/lab5.html#interrupt-flowchart",
    "title": "Lab 5",
    "section": "Interrupt Flowchart",
    "text": "Interrupt Flowchart\n\n\n\nInterrupt Flowchart"
  },
  {
    "objectID": "labs/lab5/lab5.html#motors-speed",
    "href": "labs/lab5/lab5.html#motors-speed",
    "title": "Lab 5",
    "section": "Motor’s Speed",
    "text": "Motor’s Speed\nTo calculate the motor’s speed, I used the change in time between the two pulses’ rising and falling edges. This change in time would then be plugged into a speed equation.\n\n\n\nSpeed Calculations"
  },
  {
    "objectID": "labs/lab5/lab5.html#debugging",
    "href": "labs/lab5/lab5.html#debugging",
    "title": "Lab 5",
    "section": "Debugging",
    "text": "Debugging\nThe main challenge I faced in this lab was once again a logic level issue. The voltage output on the A and B pins was sketchy and inconsistent among the motors in the lab. I didn’t realize until after many debugging hours that my HIGH logic was stepping into the forbidden zone causing interrupts to fire back to back even when there was no valid rising edge. This failure to recognize the problem led to my calculations saying that the motor was rotating consistently at 10 m/s in alternating directions every half second or so when at least one volt was applied to the motor.\nThe motor could not drive enough current with the resistors I was using in my voltage divider. So I increased my resistor values. This resulted in better and more consistent calculations.\nAnother bug I encountered was a race condition for calcualting delta_time within the interrupt handler. My mistake was using the still running timer 16 multiple times within the handler. This meant that the counter value would update as code was being executed, thus, slowing the speed calculations down dramaticaly. Setting the counter value once in the beginning of the handler was a relatively simple solution to this problem."
  },
  {
    "objectID": "labs/lab5/lab5.html#interrupting-vs-polling",
    "href": "labs/lab5/lab5.html#interrupting-vs-polling",
    "title": "Lab 5",
    "section": "Interrupting vs Polling",
    "text": "Interrupting vs Polling\nAnother popular technique to detect hardware and software events is polling. For example, one could use a while loop with an if condition checking if a signal has reached a rising edge event. However, polling can take a significant amount of time to detect events because the frequency of polling might be slower than the input signal. An interrupt has an almost immediate response to real time events. An interrupt also allows the CPU to run other parts of the program without constantly having to poll for an event. In conclusion, interrupts are faster at detecting events than polling."
  },
  {
    "objectID": "labs/lab3/lab3.html",
    "href": "labs/lab3/lab3.html",
    "title": "Lab 3",
    "section": "",
    "text": "Lab 3 Setup\n\n\n\nSummary\nThe third digital design installation in microPs involved scanning a keypad and presenting the most recently pressed key on the right side of a dual 7-segment display with the number on the left displaying the previous key pressed. The purpose for this lab was to expose students to a complex digital system with many seqeuntial and combinational elements. Additionally, the lab forced students to use oscilloscopes to fix the many timing problems that they would encounter during the debugging phase. To complete this lab, I created a design that would scan through the keypad’s columns allowing the rows to input voltages to the FPGA to be properly detected and decoded. Although this sounds simple, it was not.\n\n\nDesign\nEssentially, the scanner FSM will detect a key press and send output signals to the keypad’s columns and to the keypad decoder to preserve the current key press. While the key is still pressed, a keypad decoder decodes the key that was pushed. To verify the key push, a debouncer FSM debounces the row input signal to avoid double counting due to the switch bouncing phenomena. After the key pushed is verified to be an actual key push, the previous number gets the current number and the current number pressed is updated to the key that was pushed. These two two numbers are then sent to the time multiplexing system that displays the current number pressed on the right of the display and the previous number on the left. The block diagram for this is shown below.\n\n\n\nSystem Block Diagram\n\n\nI created this design by first deciding that my keypad would be oriented in a pull-up resistor fashion where the row inputs would be pulled to Vcc at all times until an event occurs. I then created the scanner FSM that would rotate a LOW voltage on one column at a time while the rest were driven HIGH. Thus if a key was pressed, the current column that was set LOW would send this LOW voltage across the SPDT switch that was pushed down enabling a LOW voltage to be read on that associated row. This grounding effect overpowers the weak internal pull-up resistor on the rows allowing a valid logic level voltage to be read. The electrical schematic for the system is shown below.\n\n\n\nElectrical Schematic\n\n\nIt is important to mention that the scanner FSM toggles the LOW and HIGH column voltage. When a key is pressed, all columns are driven LOW to avoid potential contention scenarios. On the otherhand when no key push is detected, all columns are toggled HIGH except for one to scan the keypad. In addition to this, the FSM sends an encoded column signal to a combinational keypad decoder module to properly decode the key press. Below is the state transition diagram for the scanner FSM.\n\n\n\nScanner FSM STD\n\n\nThis encoded column signal is bit swizzled along with the row input to check for specifc combination cases for keys. If a condition is verified, the key pushed is assigned the proper number along with a flag signal, row_bit, that is sent to the debouncer. If a key is pressed and held down, the key flag is still driven HIGH to keep the keypad from bumping the current number to the previous number.\nThe debouncer FSM takes in the row input signal that was pressed down on. This module recieves the key flag and steps into the first state to begin the counting phase. When enough clock cycles have passed, an enable signal is driven HIGH and sent to the next module that updates the current number and previous number. To prevent accidental double counting, the pulsed enable signal is driven HIGH for only one clock cycle. The state transition diagram for this FSM can be seen below along with a signal diagram.\n\n\n\nDebouncer FSM STD\n\n\nThe design updates the current and previous number through simple sequential logic. Before the current number is updated to the key pushed, the previous number gets the current number. This situation is only every carried out when the pulsed enable signal is HIGH.\nFinally, the updated current number and previous number is sent to the time multiplexing system built from lab 2. The numbers are shown on the 7-segment display on their respective sides. These numbers are illuminated every 60 clock cycles where they alternate on every set of 60 meaning that while one side is displayed, the other is turned off. This is due to the nature of the time multiplexing system where only one 7-segment decoder is used.\nAlthough syncrhonizers have not been implemented yet, they will be put in shortly in the coming week to further mitigate metastability in the system.\nOverall, the design meets the proficiency requirements. In the coming week, I will update the system to meet the excellence requirement. A shocking ~50 hours were spent on this lab. The first half of this involved not realizing that my original pull-down design for the keypad did not meet the logic level requirements for the FPGA. LOW signals would be interpreted as LOW signals, however, HIGH signals would never make it past the VIL logic level of 0.8 volts. This permanently froze the system at “00” on the display making it quite a difficult and frustrating problem to debug because the simulations showed that there should be number changes. My next short coming that led to the ridiculous amount of hours spent on the lab was confusing the active LOW logic with active HIGH at times. This led to me outputting incorrect values to the keypad’s columns creating once again a frozen system on the display. Hours of probing eventually made me realize my mistake. The last major bug that contributed to the ~50 hour effort was the keypad bumping scenario mentioned near the beginning of the design section. When a key was pressed and if the user pressed another key in a different row and in any of the columns then released the most recent key pushed, the previous number would updated to the current number. The problem here was that the key flag was being reset to zero when a key release was detected thus resetting the debouncer counter. As a result, unwanted pulsed enable signals were updating the current and previous numbers to the key that was still pressed. Putting a conditional statement within the default of a case statement fixed this issue.\n\n\nVerification\nTo verify my design, I created testbenches and manually checked the waveforms for correctness.\nThe scanner FSM received clock, reset, and row input signals. Based off of the current column signal output to the keypad, the FSM will either continue to scan or enter the pressed/released states. \nThe keypad decoder module receives the following 4 bit signals: column signal ouput to the keypad, an encoded column signal to be decoded, and a row signal. If one of the eight combinations are reached, the keypad decoder will update the key pushed value and send a row bit output as a HIGH logic value. If a combination goes to the default case, a conditional statement is reached and will check the column signals outputted to the keypad. If the logic sees that a key is still being pressed, the row bit signal will continue to be asserted HIGH and LOW otherwise. \nThe debouncer FSM recieves a clock, reset, and row bit input. When the system detects a HIGH value for the row bit, a counter starts. If the counter reaches the desired threshold, the pulse enabled signal will be driven HIGH for one clock cyle and LOW otherwise. If the row bit continues to be HIGH after this, the counter will not start back up and a LOW output will be driven through the pulse enabled wire. \nThe slide state module receives a clock, reset, pulsed enabled input, and the 4 bit key pushed signals. On the rising edge of the clock, a conditional statement check if the pulsed enabled input is set HIGH. If so, the previous number will be updated to the current number. Then, the current number will get the key pushed value.\n\nThis is the system simulation. In yellow is the current state for the scanner FSM. In purple is the key that was pushed. In cyan are the current number and previous number values. My design works for all inputs into the system. All requirements were met for proficiency."
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1",
    "section": "",
    "text": "Image of Lab 1 Setup\n\n\n\nSummary\nLab 1 introduced students to the digital design world by giving them experience with FPGA design flow from creating block diagrams to synthesizing hardware on an FPGA. The main goals of this lab were to produce a 2.4 Hz blinking LED along with driving other LEDs based on XOR and AND logic. Additionally, a seven segment display would illustrate the current hexadecimal number input from the DIP switches located on the development board.\nSeveral SystemVerilog modules produced the necessary logic to perform the requirements, and circuit analysis was used to calculate component values to drive the seven segment display according to the Specs sheet.\nOverall, this lab took 9 hours to finish which included soldering the development board together and fixing ST-link/J-link issues along with the hardware design and debugging.\n\n\nDesign\nThe first aspect to consider in the project was separating the design approaches for the two main goals: blinking an LED and driving a seven segment display. A top module would instantiate these two designs named led_controller and seg_decoder along with providing a high speed oscillator (48 MHz) developed by Lattice Radiant as seen in the BLOCK DIAGRAM BELOW.\n\n\n\nSystem Block Diagram\n\n\nThe seven segment display source code (seg_decoder) could be handled by strictly utilizing combinational logic via a case statement. The seven segment display was cathode driven, so, +3V3 supplied voltage to the common anode while the seven bit signals were attatched to the display via current limiting resistors. The calculation for the resistor values is as follows:\n\n\n\nCurrent Limiting Resistor Calculations\n\n\nWhere Vcc is the voltage source, Vd is the voltage drop across the LED, I is the desired current, and Rn is the resistor value. Solving for Rn gave a resistance value of 60 ohms for the current limiting resistors. These components contributed to the overall schematic as seen below:\n\n\n\nSystem Schematic\n\n\nThe DIP switches, reset button, and LEDs with current limiting resistors are shown in Prof. Brake’s schematic for the development board linked here.\nAs for the blinking LED (led_controller), a counter was used to delay setting the LED. The calculation is the following:\n\n\n\nCounter Limit Calculations\n\n\nThe counter limit value determines the blinking frequency with the associated clock. A reset signal initializes the counter and LED state to both 0. Until the counter reaches the desired limit, the counter increments by 1 and the LED retains its value on each clock cycle. Once the limit is achieved, the counter is reset and the LED’s value is negated thus turning the LED on/off at the desired freqeuncy.\nThe additional goals included driving XOR and AND logic on LEDs which were produced by assign statements housed inside the LED controller source code.\n\n\nVerification\nTo verify the design, an oscilloscope was used to measure the blinking LED’s freqeuncy while testbenches stimulated the source code.\nThe oscilloscope image below shows that the LED was blinking at 2.404 Hz - well within the vicinity to be considered acceptable.\n\n\n\nOscilloscope trace of a 2.4 Hz signal\n\n\nThe seg_decoder module was tested by inputting all possible switch combinations (2^4). The designer would have to manually verify that the module worked as intended by checking if each hexadecimal output was correct for each successive input.\n\n\n\nseg_decoder Waveform\n\n\nFurthermore, a testbench was created for the led_controller which now included a custom ~48MHz clock to run the sequential logic. The Lattice HSOSC library couldn’t be accessed, so a makeshift one was created. Once again, all switch combinations were supplied to the module so that the designer could analyze the XOR and AND logic. If one wished to observe the 2.4 Hz behavior for the third LED, they could do so if they had all day to wait.\n\n\n\nled_controller Waveform\n\n\nFinally, a system testbench was made to test the two submodules together. This testbench contained the same stimulus package as the led_controller testbench had.\n\n\n\nTop Module Waveform\n\n\nThe verification for all submodules and top module were successful including the oscilloscope test mentioned above. All requirements were satisfied."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Reflection 9\n\n\n\n\n\nLabs are Done and Celebrating!\n\n\n\n\n\nOct 31, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\n\n\n\n\n\n\nReflection 8\n\n\n\n\n\nFinishing up Lab 6 and Looking Towards the Future\n\n\n\n\n\nOct 24, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\n\n\n\n\n\n\nReflection 7\n\n\n\n\n\nImage Processing Accelerator Ideation and Lab 6\n\n\n\n\n\nOct 17, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\n\n\n\n\n\n\nReflection 6\n\n\n\n\n\nLabs 4/5 going into fall break\n\n\n\n\n\nOct 14, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\n\n\n\n\n\n\nReflection 5\n\n\n\n\n\nGeneral Thoughts About The Course Thus Far\n\n\n\n\n\nOct 7, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\n\n\n\n\n\n\nReflection 4\n\n\n\n\n\nMusic Playing MCU Bare Metal\n\n\n\n\n\nOct 3, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\n\n\n\n\n\n\nReflection 3\n\n\n\n\n\nKeypad Scanning\n\n\n\n\n\nSep 19, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\n\n\n\n\n\n\nReflection 2\n\n\n\n\n\nTime Multiplexing a Dual 7-Segment Display\n\n\n\n\n\nSep 13, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\n\n\n\n\n\n\nReflection 1\n\n\n\n\n\nConfiguring a 7-segment display and LEDs\n\n\n\n\n\nSep 2, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\n\n\n\n\n\n\nWeek 1 Reflections\n\n\n\n\n\nBuilt my development board and began to program in SystemVerilog\n\n\n\n\n\nAug 30, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\n\n\n\n\n\n\nHello Quarto\n\n\n\n\n\nWeek 1 Update\n\n\n\n\n\nAug 27, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Troy Kaufman is a junior general engineering major at Harvey Mudd College. He has a deep interest in digital design with hopes of entering the computer architecture field. As an intern with The Aerospace Corporation this past summer, he worked on facilitating communication between an FPGA and SPI NOR flash memory. Troy also created an FPGA subsystem that monitored and replied to a proprietary satellite interface. His hobbies include playing disc golf, scripted wrestling, and building weird devices with friends."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2",
    "section": "",
    "text": "Lab2 Setup\n\n\n\nSummary\nThis lab introduced students to a method of reusing valuable resources - multiplexing. In this case, students were required to time multiplex a dual 7-segment display along with illustrating the sum between two hexadecimal numbers shown on the display. SystemVerilog modules were created to build a multiplexing FSM, 7-segment decoder, and adder respectively. This lab took a total of 15 hours to complete. Nine of these hours were focused on debugging a floating value problem in the mechanical design which will be mentioned in the design section. Overall, all requirements were met.\n\n\nDesign\nA top module instantiated a Lattice Radiant clock, multiplexing FSM, 7-segment decoder, and adder. The main part of this design revolved around an FSM turning on one side of a dual 7-segment display at a time while sending the appropriate hexadecimal data to the segment decoder for the number to be displayed. This FSM included 3 states: S0 (reset), S1 (1st hex number), S2 (2nd hex number). Once the active low reset button was driven, the FSM would alternate from S1 to S2 at a fast enough pace for a human not to notice flickering but slow enough to avoid bleeding the numbers together on the display. The A and Abar signals on the state transistion diagram arcs represent counter inputs to the FSM. Only when the counter has reached a specific value is when the A arc is followed. Otherwise, the Abar arc is followed.\n\n\n\nState Transistion Diagram\n\n\nAs mentioned before, there are four submodules in the overall design. Below is the system block diagram. The hex_num_controller module contains the FSM. It will receive a clock and active low reset input. It will output two transistor signals to drive the display and one encoded signal, display_num, to the segment_decoder module. This encoded signal will tell the segment_decoder module which hexadecimal input to illustrate on the display. All the while this happens, an adder in led_sum will sum the two inputs and show the result on five LEDs.\n\n\n\nBlock Diagram\n\n\nTo properly multiplex the dual 7-segment display, two PNP transistors controlled their own common anode pins on the display. One would supply a flow of current to a number’s segments while the other transistor would limit the current, thus, turning one number on and the other one off. To protect the FPGA from current damage coming from the emitter, a 330 ohm resistor was put in series with the base. This limited the FPGA to output a current of 7.8 mA, below the soft 8 mA recommended maximum output current listed in the FPGA data sheet on Table 4.13 on pg 34.\nThe PNP 2N3906 transistor current gain for this particular instance can be found on pg 6 in Figure 13.\nThe following calculation and explanation shows why a 330 ohm resistor was used in the design. \nThe current limiting resistors for the cathode inputs into the display and LED sum calculation is as follows:\n\n\n\nCurrent Limiting Resistor Calculation\n\n\nThe electrical schematic shown below displays all the electrical components needed to complete the requirements including the dual 7-segment display, DIP switches, and current limiting resistors. Note that the DIP switches are using internal pull-up resistors as noted in the development board’s schematic\n\n\n\nElectrical Schematic\n\n\nAs previously mentioned, I did encounter a frustrating issue with floating values in my design. Initial debug attempts were focused at resoldering, using new switch inputs, using new ribbon cable, etc. Eventually, the problem was tracked down to the internal pull-up resistors. Their default values on the Lattice Radiant tool is 100k ohms. I found that using 3.3K ohms was perfect to prevent the floating value problem.\n\n\nVerification\nTestbenches were used to verify my design in simulation. The design worked in all testbench assessments.\nThe unit 7-segment decoder testbench was used to check if all segments in a hexadecimal number would be driven properly. Stimulants in the testbench tested all 16 numbers. All of them were correct. \nThe following testbench checked if the internal encoded display_num signal would be properly set/reset after a given number of clock cycles. The blue signal shows the encoded signal. The purple and orange signals show the current inputs to the transistors for driving the hex number display. We wanted to see the that the FSM behavior would show the encoded signal being driven whilst the hex2_num signal was reset to low and vice versa with the hex1_signal. A high enconded signal with a low hex2_num signal prompts the system to display the second number. A low encoded signal with a low hex1_num prompts the system to display the first number.\n\n\n\nFSM Hexadecimal Display Controller Waveform\n\n\nThis testbench tests if the adder works correctly. This is a simple combinational testbench that works fine. \nThis system testbench tests the entire design’s effectiveness to a variety of switch inputs. Overall, this testbench design is very similar to the FSM testbench except for the fact that the high speeded oscillator clock is instantiated in this one. \nOverall, my design worked as planned and successfuly implemented the requirements in lab 2. This lab took me a total of 15 hours. The source code for the lab can be found here."
  },
  {
    "objectID": "labs/lab4/lab4.html",
    "href": "labs/lab4/lab4.html",
    "title": "Lab 4",
    "section": "",
    "text": "Summary\nStudents needed to bare metal program their MCUs to play Fur Elise on an 8-ohm speaker. The purpose of this lab was to get students familiar with navigating a large datasheet for relevant information pertaining to the project at hand as well as interact with an MCU on a very low level. The lab intoduced timers which are specialized counters with extreme accuracy. Students needed to configure timers to produce the requested frequency and delay to properly produce the song. Device drivers were made from scratch too.\n\n\nDesign\nPrior to this lab, I was familiar with configuring GPIO and RCC registers, however, I needed to understand how timers worked. Before I began designing anything, I researched the various timers available on the MCU. I chose timers 15 and 16 because they had output pads and contained the PWM function unlike other available timers. The harware components this lab were relatively simple to setup:\n\n\n\nDesign’s Electrical Schematic\n\n\nI focused on how to produce a PWM signal first. The reference manual for this particular STM32xxx on page 906 ambiguously stated how to configure a timer for a PWM operation. I made note of these important signals and bit flipping. I traveled to the timer 16’s memory mapped section. Within my TIMER device driver, I created two functions whose purpose were to initialize the PWM configuration for timer 16 once and to update several configuration registers upon every clock cycle respectively. The most notable registers were the prescalar (PSC) and auto-reload (ARR) registers.\nThe PSC acted as a clock divider to either improve or decrease resolution according to the designer’s request. In this project I needed my frequencies to be within 1% of the requested freqeuncies. So I put my input clock to the counter to be 10 KHz wheras the input clock to the timer was 1 MHz. The relatively low 10 KHz clock speed provided good resolution. I calculated the PSC divisor value by using the following equation:\n\n\n\nPrescalar Divisor Equation\n\n\nThe next important configuration register to consider was the ARR. This register held the value that the counter would increment towards to in order to produce the requested freqeuncy. I recognized the following relationship between the value housed in ARR and the input frequency where CK_CNT represents the 10 KHz counter input and CK_PSC is the 1 MHz signal.\n\n\n\nARR PWM Calculation\n\n\nMy design choices for the counter clock forces my minimum and maximum frequency calculations to be the following:\nCalculation for minimum frequency supported: This is calculated by first considering the the counter’s input clock frequency (10 KHz) and bit width of the counter (16 bits as discussed in the manual on page 887). By assuming that the counter will reach 65536 ticks, we can find the value for when the MCU will output its lowest freqeuncy:\n\n\n\nMinimum Freqeuncy Supported\n\n\nCalculation for maximum freqeuncy supported: This is calculated very similarly to the minimum frequency calculation. However, the amount of times the counter has clicked will no longer be the counter’s maximum value but rather its minimum value - 1:\n\n\n\nMaximum Frequency Supported\n\n\nNow we will cover how I implemented a delay function for a given duration. It is a similar process to how I implemented the PWM mode for timer 16. I used timer 15, and put the timer in its upcounting mode to strictly increment. Most of the same registers used for implementing the PWM signal were used for the delay function with an exception for a handful that were used for comparison registers. I created initialization and update functions for the delay where the former would only ever update those registers once while the update function would consistently refresh the values in several registers. The major difference between the PWM and delay functions was that there was a while loop with the delay update function checking for when a flag would be set when the duration limit had been satisfied. At that point, the while loop would end and the flag would be reset for the next delay then the next line would run.\nThe PSC calculation for the delay register is the same as the one in the PWM register.\nThe ARR calculation is different because we are no longer receiving an input frequency but rather a duration. To build this equation, I had to consider how fast the tick in the counter would increment in upcounting mode (page 893 in the reference manual). With a 10 KHz input counter clock, the counter would tick every 100 us. So, the duration was multiplied by 10 to get the the duration in terms of ms. Then a value of one was subtracted from this to get the following ARR equation:\n\n\n\nARR Delay Calculation\n\n\nMy design choices for the counter clock forced my minimum and maximum duration calculations to be the following:\nCalculation for minimum duration supported: This is the reciprocal of the input counter clock, 10 KHz.\n\n\n\nMinimum Duration Calculation\n\n\nCalculation for maximum duration supported: The maximum duration is calculated by dividing the maximum number of ticks in the 16 bit counter by the input clock frequency entering the counter:\n\n\n\nMaximum Duration Calculation\n\n\n\n\nVerification\nThe design works perfectly. The only quirk about it is that it takes about 4 seconds for the system to start performing the song after the program starts. I spent about 15 hours on this lab.\nThis is a video of my design playing Fur Elise with volume manipulation from a potentiometer. \nThis is a video that displays my Happy Birthday song. \nBelow are calculations that show the individual pitches are accurate to within 1% of the requested freqeuncy. The measured values seen in the images are captured from an oscilloscope.\n \nThis was a very fun lab, and I can’t wait to play more songs!"
  },
  {
    "objectID": "labs/lab6/lab6.html",
    "href": "labs/lab6/lab6.html",
    "title": "Lab 6",
    "section": "",
    "text": "Logic Analyzer Trace Showing a Room Temperature of 23.5 C"
  },
  {
    "objectID": "labs/lab6/lab6.html#approach",
    "href": "labs/lab6/lab6.html#approach",
    "title": "Lab 6",
    "section": "Approach",
    "text": "Approach\nMy approach to the design involved becoming comfortable with the SPI peripherals on the STM MCU. I tracked the relevelant configuration registers and bits within them to properly configure SPI. I used the _VAL2FLD HAL to initialize these bits in initSPI(). Another important function, spiSendReceive(), took in a byte input that would be placed in the data register (DR) within SPI. This proved challenging at first because the DR was 16 bits long but the SPI system was running at 8 bits. The following manipulation was done:\n\nCaptured the DR’s address in memory\nCasted the 16-bit value in DR as a volatile 8-bit integer pointer\nDereferenced this value\nFinally let this complicated manipulation receive the byte of data\n\nAdditionally, this function retrieved the data stored in the DR only when data was available.\nNext I created a file that would configure the temperature sensor settings (writeRes()) and another function that would read the 2s complement formatted input temperature (readTemp()) and convert it to the proper value.\nWhen the user requests a temperature resolution, that data gets sent to the MCU where writeRes() would parse the information and correctly configure the temperature sensor’s output setting accordingly. The sensor would then send an updated temperature value to the MCU where readTemp() would parse the two bytes of information. The first byte is shifted to left 8 times and the second byte would be concatenated to this value creating a 16 bit integer. Depending on the specific resolution requested, the data would then be shifted to the right where the actual LSB of the data would be in the 0th place of the 16 bit integer. Once again according to the resolution selected, the data would then be multiplied by a specific value less than zero to get the data to contain decimal places. With a simple float cast to these outputs and some additional logic to handle negative 2s complement numbers, data can be correctly read from the sensor.\nTo display the temperature on the monitor, html code was written to allow users to interact with buttons on screen to choose up to 5 different temperature resolutions. The network setup, USART, and most of the html was provided with the lab.\nHere is the system setup:"
  },
  {
    "objectID": "labs/lab6/lab6.html#spi-formatting",
    "href": "labs/lab6/lab6.html#spi-formatting",
    "title": "Lab 6",
    "section": "SPI Formatting",
    "text": "SPI Formatting\nThe entire data transfer process consists of 6 bytes where the first two bytes will always configure the temperature sensor while the latter four bytes would initiate a read access in certain sensor registers and eventually receive the data.\nThe first byte is initiaiting a write transaction to the sensor by sending 0x80 - the address of the configuration register within temperature sensor’s memory map. The second byte is the actual data that is being transfered to the configuration register. This byte will contain the necessary information to setup the requested temperature resolution in the sensor’s temperature calculations.\nThe third byte, 0x02, is requesting to read the MSByte of the temperature data. Just like with writing data, we cannot read/write data on the same transfer. So, the fourth byte sends a dummy byte to sensor so that SPI clock cycles get sent. As a result, the MCU receives the MSByte of temperature data. The fifth and sixth bytes work in the same fashion as the third and fourth, however, the third byte would request the LSByte of temperature data."
  },
  {
    "objectID": "labs/lab6/lab6.html#debugging",
    "href": "labs/lab6/lab6.html#debugging",
    "title": "Lab 6",
    "section": "Debugging",
    "text": "Debugging\nThe common bugs that I encountered during this lab included sending data packets in a non-recognizable format by the sensor and reading data back to the MCU without writing a dummy byte back to the sensor to initiate the data trasnfer. MY most frustrating bug took me around 5 hours to debug because a simple assumption: my wiring was correct. It turned out that I accidentally switched the SDI and SDO ports. On the logic analyzer, this looked like I was able to write valid data, but my readings would always be floating gibberish. I won’t make that mistake again."
  },
  {
    "objectID": "labs.html",
    "href": "labs.html",
    "title": "E155 Labs",
    "section": "",
    "text": "Lab 7\n\n\n\n\n\nImplementing AES 128-bit Encryption\n\n\n\n\n\nOct 30, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\n\n\n\n\n\n\nLab 6\n\n\n\n\n\nReading temperature sensor data over SPI\n\n\n\n\n\nOct 23, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\n\n\n\n\n\n\nLab 5\n\n\n\n\n\nUsing Interrupts to Detect a Motor’s Velocity\n\n\n\n\n\nOct 10, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\n\n\n\n\n\n\nLab 4\n\n\n\n\n\nBare Metal Programming on an MCU to Produce Music\n\n\n\n\n\nOct 3, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\n\n\n\n\n\n\nLab 3\n\n\n\n\n\nScanning and Debouncing a Keypad\n\n\n\n\n\nSep 19, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\n\n\n\n\n\n\nLab 2\n\n\n\n\n\nTime Multiplexing a Dual 7-Segment Display\n\n\n\n\n\nSep 13, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\n\n\n\n\n\n\nLab 1\n\n\n\n\n\nSeven Segement Display and LED logic\n\n\n\n\n\nSep 3, 2024\n\n\nTroy Kaufman\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/lab1.html",
    "href": "posts/lab1.html",
    "title": "Reflection 1",
    "section": "",
    "text": "Hi all! I recently finsihed the first lab in MicroPs, and it was overwhelmingly satisfying to see my hardwork pour into a successful project. Despite the premise being to turn on LEDs in various fashions, the lab was gruelling in some aspects. This lab was a neat introduction to the digital design world.\nThe most exciting part about the lab was designing the counter needed to blink an LED at 2.4 Hz. There is a handful of ways to perform this operation, and I did end up trying some of them out to see which method would produce the closest blinking freqeuncy. It was fun trying this out. However, this ended up being one of the most frustrating parts of the lab as well. I incorrectly gave my counter 22 bits when in reality it needed 25 bits to operate. This oversight caused hours of pain and eventual embarassment aft the bug was caught.\nOverall, this was an entertaining lab that showed me the FPGA design flow in Lattice Radiant. It took sometime getting used to the new tool, howeever, I don’t doubt that with some practice I can maneuver around with no difficulty."
  },
  {
    "objectID": "posts/lab3.html",
    "href": "posts/lab3.html",
    "title": "Reflection 3",
    "section": "",
    "text": "First off, this was a time consuming and gruelling lab. I spent over 40 hours on the lab, and I still haven’t finished it. However, it’s been a wonderful learning experience filled with “Ah-Ha” and “Oh-No” moments. This lab built off the two previous ones where counters were used in multiple places and the time multiplexing scheme was used to display the pressed keys. Designing, implementing, and debugging this system was an entirely different beast. Clock domain crossing was considered, debouncing logic was needed, many submodules communicated with each other, and a complex FSM was built to scan the keypad in such a way to account for all possible human inputs and tomfoolery when it came to pressing keys on the keypad. Despite not having finished it like most others, I am proud of the work I’ve done so far, and I’m determined to finish the lab in the next couple days. The digital design aspect of this course has been a great introduction to digital electronics. I’m looking forward to the next FPGA based lab in about a month or so when we create AES on an FPGA and MCU."
  },
  {
    "objectID": "posts/reflection5.html",
    "href": "posts/reflection5.html",
    "title": "Reflection 5",
    "section": "",
    "text": "The past two weeks have been incredibly fun and satisfying. I managed to finish lab 4 (timers), and I’m very close to finishing lab 5 (interrupts). Through the past 7 weeks, I’ve learned that this course is a debugging masterclass more than anything else. Creating a design to solve a problem is not so hard to do. Constantly monitoring input and output signals and everything in between are the most difficult parts.\nFrustration often kicks in hard and fast. The best way I’ve managed to combat this is to step away from the workbench and walk around the orange trees behind the engineering building. This affords me time to think about other things in life. This class is difficult, time consuming, and thought provoking. Everyone I have talked to has said that they have shed tears over this class at one point or another this semester. It’s a natural thing to be stressed out, but it’s how we react to the stress that truly defines ourselves as problem solvers. If anybody could do it, then MicroPs would be a 100 person class but that’s not reality.\nI have learned more this semester in this one class compared to the rest of my time at Mudd. I’m proud of myself for being independent in this course. It has forced me to think about different approaches and how to implement them. In other classes, many students work in groups to get psets or labs done. I’ve noticed some people in this class tend to work in pairs/groups which is completely justified. However, I think they’re missing the main purpose that this course is providing them: an opportunity to struggle - ALONE - on NEW and COMPLEX systems.\nMy girlfriend hates this class because of how much time I devote to it. I often joke around and say that the digital lab is my second home (Xavier, the GOATED engineering assistant, has commented on this too). I’m happy that I’m already halfway through the labs, but I’m saddened by it because I know that I won’t experience this with another class at Mudd ever again. This course has brought me joy, tears, maniacal laughter, fist pumps in the air, frustration, expletive comments (happy and sad), and best of all satisfaction. MicroPs has brought me on a rollercoaster of emotions and I ABSOLUTELY LOVE IT!!!"
  },
  {
    "objectID": "posts/reflection7.html",
    "href": "posts/reflection7.html",
    "title": "Reflection 7",
    "section": "",
    "text": "I had my project proposal checkoff earlier today and it went really well! All my research and effort into organizing the system paid off. Throughout this research period, I learned a lot about Direct Memory Access (DMA) and its purposes. It’s necessary to use this feature in a microcontroller when the designer needs the CPU to be handling tasks continuously without frequent disruptions from managing data traffic.\nIt seems like the project is on the right path for now. I’ll be researching DMA in-depth next week about the relevant registers and bits that need to be manipulated for the two DMA channels that I’ll be using. The grayscale implementation should be rather easy to put in as it requires some byte management and a trivial calculation.\nI’ll be starting lab 6 this week which should help me with understanding how to configure the SPI protocol on the STM32. This lab will also give me the chance to use a hardware logic analyzer. I’ve used Xilinx Vivado’s logic analyzer in the past, but it was tedious to setup and wasn’t all to helpful. This upcoming week should be fun!"
  },
  {
    "objectID": "posts/reflection9.html",
    "href": "posts/reflection9.html",
    "title": "Reflection 9",
    "section": "",
    "text": "Happy Halloween!!!It’s been a very fun week thus far. I completed lab 7 marking the end of the lab section of the course! I knew that this course was the most difficult class at Harvey Mudd, but I didn’t realize how much time I would invest into the class. I’ve grown so much these past two months.\nA handful of others including myself decided to host an event to celebrate the end of a gruelling two and a half months of work. It was microP themed with all the bells and whistles. I will add that our event was better than the competition…microPs for the win!!!\nThis upcoming week, I will be implementing I2C on the MCU to configure a camera module for the project. Additionally, I will look into how DMA works to get ahead of schedule a little bit. This project has a lot of moving parts, and I fear that we might not finish this project in time. Fortunately, Vikram and I were able to get Joesph on our team so hopefully this lightens the load on us.\nOverall, I’m feeling relaxed at this point in the semester and confident in my ability to program embedded systems."
  }
]